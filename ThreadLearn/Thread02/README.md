#### demo01 单例模式的多种写法
#### demo02 wait set的原理
#### demo03 volatile关键字详解

##### 缓存不一致解决方案

1.  给数据总线加锁
    * 当cpu读取某变量时 对该变量所在区域加锁 使其在该代码段下 串行化

2. cpu高速缓存一致性协议 
    * 当cpu写入数据时 发现该变量被共享 发出信号  通知其他cpu 该变量缓存无效
    * 当cpu访问该变量时 重新到主存中获取


##### 并发编程遵循的特性
* 原子性 要么成功,要么都失败
* 可见性 线程A更新值后 线程B会感知到
* 有序性 java中存在重排序(java编译器保证最终的一致性)


##### java如何确保上述的特效

1. 原子性 对基本数据类型的变量的读取与赋值保证原子性 要么成功 要么失败(通过加锁解决)
```
    a=10    满足原子性
    b=a     不满足 ,1.read   2.assign b
    c++     不满足 ,1.read  2.add  3.assign c
    c=c+1  不满足 ,1.read  2.add  3.assign c
    
    double与long 也不满足原子性 存在高低位赋值操作
```

2. 可见性 使用volatile关键词保证可见性

    <u>变量被volatile修饰 一旦被修改 所有cpu中缓存失效 修改值刷回主存 读取该变量从主存中读取  </u>

3. 有序性 (happend-before)
    1.    一个线程代码的执行顺序,编写在前面的 发生在 编写在后面之前
    2.    unlock必须在lock之后
    3.    volatile修饰的变量, 对变量的写操作**先于**对该变量的读操作
    4.    操作A先于B 操作B先于C 则操作A先于C
    5.    ~~线程启动规则:     start方法先于线程执行的操作~~
    6.   ~~线程的中断规则:  interrupt的方法必须发生在捕获该动作之前~~
    7.    ~~对象的销毁规则: 初始化必须发生在finalize之前~~
    8.    ~~线程终结原则  :  所有操作发生在线程死亡之前~~