### 废话不多说 直接主题  
1. ##### 原因  
. 由于自己最近学的是spring框架 讨论到aop思想 需要引入动态代理的概念 发现自己忘记了 因此写一篇来了解一下  
. 开发如果总是crud操作 未必对自己有好处 需要引入新的知识

2. ##### 内容概述  
. 代理是什么为什么需要代理  
. 代理有哪几种 如何去使用

#### 内容：
什么是代理：
> 代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗来说代理模式就是我们生活中常见的中介  

为什么需要代理:  
> 最好的例子就是代购 小王有个美丽的夫人叫小马，小王经常要去拍电影，没时间回去给夫人买包包啊什么的，长此以往感情肯定会不和，怎么办呢？于是小宋作为一名助手承担了这项业务，业务逻辑如下 小王购买一个包包交给小宋 并告诉小宋 你把这个包送给小马 但是第一 在送的时候请保密 第二 送完之后陪她看场电影 小宋执行上述命令!  
> 从业务逻辑上来说 实际对象(小王)由于某种业务上的原因没有办法直接执行自己的方法, 这时候小宋作为代理对象包装了小王的诉求并执行.这就称之为代理模式!

代理有哪几种
> 动态代理 和 静态代理

##### 静态代理  
　　 静态代理是将多个方法放在一个接口1进行封装,后有代理类和真实对象进行实现,注意被代理对象实现自己业务方法,而代理类在实现方法时,需要引入一个实现接口1的类 这时候我们就将被代理对象封装进去,但由于业务方法都实现了接口类,从业务逻辑上说,代理对象具有了和被代理对象的相同属性  

```
        crud subject = new relSubject();//被代理对象
        crud proxy = new Proxy1(subject);//代理对象
        proxy.follower();//执行被代理对象的方法同时 自己可以进行操作(业务增强)
```
##### 动态代理
　　随着业务的不断扩展,小宋的业务也做的越来越大,于是乎成立了一个代理公司,有做了其他业务,也就代表需要实现更多的接口,这时候会发现代码的扩展性被耦合死了,如果扩展公司,唯一的方法就是修改代码,在设计代码中修改代码就相当于禁区,怎么办?动态代理因运而生!
>首先由代理类去实现一个特定的接口 InvocationHandler 该接口需要去实现   

```  
public Object invoke(Object proxy, Method method, Object[] args)
{
    Object ret = method.invoke(factory, args);
    return ret;
}  

//返回代理对象
public Object getproxyInstance() {
       Object instance = Proxy.newProxyInstance(factory.getClass().getClassLoader(), factory.getClass().getInterfaces(), this);
       return instance;
}
```
　　注意上述的就是一个代理类 但是我们被代理的类也必须去实现自身的业务接口,
这样当我们需要扩展业务时,只需要在放入被代理类,就会返回一个object对象,由强转为接口,就可以执行相应的方法!


[见设计模式](https://github.com/johncows/Design-mode)
